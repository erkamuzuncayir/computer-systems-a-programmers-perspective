1. pp.1
    1. 0011 0101 1011 1001 1101 0010
    2. AE49
    3. 1010 1000 1100 0011 1101
    4. 0x322d95
2. pp.2
    1. 8388608 / 0x800000
    2. 15 / 0x8000
    3. 13 / 8192
    4. 4096 / 0x1000
    5. 6 / 0x40
    6. 8 / 128
3. pp.3
    1. 1001 1110 / 0x9e
    2. 1100 0100 / 0xc4
    3. 1001 0001 / 0x91
    4. 174 / 0xae
    5. 60 / 0x3c
    6. 241 / 0x151
4. pp.4
    1. 117 / 0111 0101
    2. 189 / 1011 1101
    3. 245 / 1111 0101
    
5. pp.5
    1. 0x6061
    2. 0x603c
    3. 0x607c
    4. 0x9e
    
6. pp.5
    1. 8 / 1
    2. 78 / 12
    3. 6 78 / 12 3
    
7. pp.6
    a. 
        1. 00000000001001111100100011111000 
        2.   01001010000111110010001111100000
    b. 21
    c. 11 bits. First 9 and last 2 bits.
    
8. pp.7
    - `6d 6e 6f 70 71 72`.

9. pp.8
    1. 10110001
    2. 00011110
    3. 01000000
    4. 11101111
    5. 10101111
    
10. pp.9
    a. 
        1. white
        2. yellow
        3. magenta
        4. red
        5. cyan
        6. green
        7. blue
        8. black
    b. 
        1. cyan
        2. green
        3. blue
        
11. pp.10
        1. 
            1. *x = *x  /   *y = *x ^ *y;
            2. *x = *x ^ (*x ^ *y)  / *y = *x ^ *y
                1. *x = *y  / *y = *x ^ *y
            3. *x = *y  / *y = *x ^ (*x ^ *y)
                1. *x = *y  / *y = *x
                
12. pp.12
        1. x & 0xFF
        2. x ^ ~0xFF
        3. x | 0xFF
        
13. pp.13
        1. bis(x, y)
        2. bis(bic(x, y), bic(y, x))
        
14. pp .14
        1. 0100 0100 / 1
        2. 0101 0111 / 1
        3. 1011 1011 / 0
        4. 0000 0000 / 1
        1. 0101 0101
        2. 0100 0110
        
        1001
        1001
        
        1001
        1001
        0000
        
        0000
        
        
        or not or not
        
- 2.27 
```c
int uadd_ok(unsigned x, unsigned y)
{
    return x + y < x;
}
```

- 2.29

1. S
    1. 100101 / 00101 / 5
    2. 110000 / 10000 / -16
    3. 11111 / 11111 / -1
    4. 00111 / 0111 / 7
    5. 10000 / 0000 / 0
    
- 2.30

```C
int tadd_ok(int x, int y)
{
    if((x < 0 && y < 0 && x + y >= 0 ) || (x >= 0 && y >= 0 && x + y < 0))
        return 0;
        
    return 1;
}
```

- 2.34
        1. 4 * 5 = 20 = 4 = 100
        2. -4 * -3 = 12 = -4 = 100
        3. 2 * 7 = 14 = 6 = 110
        4. 2 * -1 = -2 = -2 = 110
        5. 6 * 6 = 36 = 4 = 100
        6. -2 * -2 = 4 = -4= 100
        
        
        (x<0 ? x+(1<<k)-1 : x) >> k
        
- 2.45
        1. 0.11     /   0.75
        2. 0.0101   /   0.3125
        3. 2+11/16  /   2.6875
        4. 1.001    /   1.125
        5. 5+7/8    /   101.111
        6.          /   11.0011
        
        e = exponent bit value
        e = 0
        Bias = 2^(E - 1) - 1
        bias = 2^(4 - 1) - 1 = 7
        E = 1 - bias // denormalized
        E = e - bias // normal       
        M = 1 + f
- 2.46 
            e   E   2^E f       M       2^E*M   V       Decimal
        1.  0   0   1   0       0       0       0       0.0
        2.  0   0   1   1/4     1/4     1/4     1/4     0.25
        3.  0   0   1   2/4     2/4     2/4     1/2     0.50
        4.  0   0   1   3/4     3/4     3/4     3/4     0.75
        5.  1   0   1   0       4/4     4/4     1       1.00
        6.  1   0   1   1/4     5/4     5/4     5/4     1.25
        7.  1   0   1   2/4     6/4     6/4     3/2     1.50
        8.  1   0   1   3/4     7/4     7/4     7/4     1.75
        9.  2   1   2   0       4/4     8/4     2       2.0
        10. 2   1   2   1/4     5/4     10/4    5/2     2.50
        11. 2   1   2   2/4     6/4     12/4    3       3.0
        12. 2   1   2   3/4     7/4     14/4    7/2     3.5
        13. INFINITY
        14. NaN
        15. NaN
        
        2^(-n-1)
        
        11
        11
        11
        11
        
        0.00011001100110011001100
        0.00011001100110011001101

- 2.54
  - true
  - false
  - false
  - true
  - true
  - true
  - true
  - false